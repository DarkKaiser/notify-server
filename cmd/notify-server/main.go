package main

import (
	"context"

	"fmt"
	"os"
	"os/signal"
	"sync"
	"syscall"
	"time"

	"github.com/darkkaiser/notify-server/internal/config"
	"github.com/darkkaiser/notify-server/internal/pkg/version"
	"github.com/darkkaiser/notify-server/internal/service"
	"github.com/darkkaiser/notify-server/internal/service/api"
	"github.com/darkkaiser/notify-server/internal/service/notification"
	"github.com/darkkaiser/notify-server/internal/service/notification/notifier"
	"github.com/darkkaiser/notify-server/internal/service/notification/notifier/telegram"
	"github.com/darkkaiser/notify-server/internal/service/task"
	_ "github.com/darkkaiser/notify-server/internal/service/task/kurly"
	_ "github.com/darkkaiser/notify-server/internal/service/task/lotto"
	_ "github.com/darkkaiser/notify-server/internal/service/task/naver"
	_ "github.com/darkkaiser/notify-server/internal/service/task/navershopping"
	applog "github.com/darkkaiser/notify-server/pkg/log"
)

// @title Notify Server API
// @version 1.0.0
// @description 웹 스크래핑을 통해 수집한 정보를 알림으로 전송하는 서버의 REST API입니다.
// @description
// @description 이 API를 사용하면 외부 애플리케이션에서 텔레그램 등의 메신저로 알림 메시지를 전송할 수 있습니다.
// @description
// @description ## 주요 기능
// @description - 알림 메시지 전송
// @description - 다양한 알림 채널 지원 (Telegram 등)
// @description - 애플리케이션별 인증 및 권한 관리
// @description
// @description ## 인증 방법
// @description API 사용을 위해서는 사전에 등록된 애플리케이션 ID와 App Key가 필요합니다.
// @description 설정 파일(notify-server.json)의 notify_api.applications에 애플리케이션을 등록한 후 사용하세요.
// @description
// @description ## 인증 플로우
// @description 1. **사전 준비**: notify-server.json의 notify_api.applications에 애플리케이션 등록
// @description    - application_id, app_key, default_notifier_id 설정
// @description 2. **API 호출**: Query Parameter로 app_key 전달
// @description    - POST /api/v1/notifications?app_key=YOUR_KEY
// @description 3. **인증 검증**: 서버에서 application_id와 app_key 확인
// @description    - 미등록 앱: 401 Unauthorized
// @description    - 잘못된 app_key: 401 Unauthorized
// @description 4. **알림 전송**: 인증 성공 시 텔레그램으로 메시지 전송
// @description    - 성공: 200 OK
// @description
// @description 자세한 인증 플로우 다이어그램은 GitHub README를 참조하세요.

// @termsOfService http://swagger.io/terms/

// @contact.name DarkKaiser
// @contact.url https://github.com/DarkKaiser
// @contact.email darkkaiser@gmail.com

// @license.name MIT
// @license.url https://github.com/DarkKaiser/notify-server/blob/master/LICENSE

// @host api.darkkaiser.com:2443
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in query
// @name app_key
// @description Application Key for authentication

// @externalDocs.description API 인증 가이드 (인증 플로우 다이어그램 포함)
// @externalDocs.url https://github.com/DarkKaiser/notify-server#api-인증-플로우

const (
	banner = `
  _   _         _    _   __          ____
 | \ | |  ___  | |_ (_) / _| _   _  / ___|   ___  _ __ __   __  ___  _ __
 |  \| | / _ \ | __|| || |_ | | | | \___ \  / _ \| '__|\ \ / / / _ \| '__|
 | |\  || (_) || |_ | ||  _|| |_| |  ___) ||  __/| |    \ V / |  __/| |
 |_| \_| \___/  \__||_||_|   \__, | |____/  \___||_|     \_/   \___||_|
                             |___/                           %s
                                                        developed by DarkKaiser
--------------------------------------------------------------------------------
`
)

const (
	// shutdownTimeout 종료 시그널 수신 후 최대 대기 시간
	shutdownTimeout = 30 * time.Second
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "%v\n", err)
		os.Exit(1)
	}
}

func run() error {
	// 1. 환경설정 로드
	// 애플리케이션 구동에 필요한 모든 설정(로깅, 타임아웃, 포트 등)을 파일로부터 읽어 메모리에 적재합니다.
	// 이 단계가 실패하면 서버는 정상 동작할 수 없으므로 즉시 종료됩니다.
	// 반환된 경고 메시지(warnings)는 로그 초기화 후 출력합니다.
	appConfig, warnings, err := config.Load()
	if err != nil {
		return fmt.Errorf("환경설정 파일을 로드하는 중 치명적인 오류가 발생했습니다: %w", err)
	}

	// 2. 로그 시스템 초기화
	// 환경설정(Debug 모드 여부)에 따라 개발용 또는 운영용 로거를 구성합니다.
	// 초기화된 클로저(appLogCloser)는 함수 종료 시 반드시 호출하여 버퍼에 남은 로그를 플러시해야 합니다.
	var logOpts applog.Options
	if appConfig.Debug {
		logOpts = applog.NewDevelopmentOptions(config.AppName)
	} else {
		logOpts = applog.NewProductionOptions(config.AppName)
	}
	// 로그 파일 경로 단축을 위해 프로젝트 모듈 경로 주입
	logOpts.CallerPathPrefix = "github.com/darkkaiser/notify-server"

	appLogCloser, err := applog.Setup(logOpts)
	if err != nil {
		return fmt.Errorf("로그 시스템을 초기화하는 중 치명적인 오류가 발생했습니다: %w", err)
	}
	defer appLogCloser.Close()

	// 3. 운영 적합성 진단
	// 서비스 안정성과 보안을 높이기 위한 권장 설정 준수 여부를 검사한 결과입니다.
	// 미준수 항목은 경고(Warn) 레벨로 로깅되며, 실행 흐름에는 영향을 주지 않습니다.
	for _, warning := range warnings {
		applog.WithComponent("config").Warn(warning)
	}

	// 4. 서버 아이덴티티 출력
	// 서버 시작 시 시각적으로 식별 가능한 배너(Ascii Art)와 버전 정보를 출력하여,
	// 운영자가 현재 구동되는 서버의 종류와 버전을 직관적으로 확인할 수 있게 합니다.
	fmt.Printf(banner, version.Version())

	// 5. 빌드 메타데이터 조회
	buildInfo := version.Get()

	// 6. 초기화 시작 로그 기록
	applog.WithComponentAndFields("main", applog.Fields{
		"env":          map[bool]string{true: "development", false: "production"}[appConfig.Debug],
		"version":      buildInfo.Version,
		"commit":       buildInfo.Commit,
		"build_date":   buildInfo.BuildDate,
		"build_number": buildInfo.BuildNumber,
		"go_version":   buildInfo.GoVersion,
		"os":           buildInfo.OS,
		"arch":         buildInfo.Arch,
	}).Info("Notify Server 초기화 프로세스를 시작합니다")

	// 7. 서비스 객체 생성 및 연결
	// 각 서비스가 작동하는 데 필요한 의존성(다른 서비스)을 주입하여 전체 시스템을 조립합니다.
	//
	// [참고: 순환 의존성 해결]
	// Task와 Notification은 서로를 필요로 하는 관계입니다. (Task -> Notification, Notification -> Task)
	// 이를 해결하기 위해 생성자 주입(Constructor Injection)과 세터 주입(Setter Injection)을 혼용하여 연결을 완성합니다.

	// Task Service 생성
	taskService := task.NewService(appConfig)

	// Notification Factory 생성 및 Processor 등록
	notifierFactory := notifier.NewFactory()
	notifierFactory.Register(telegram.NewFactory(telegram.NewNotifier))

	// Notification Service 생성
	notificationService := notification.NewService(appConfig, notifierFactory, taskService)

	// API Service 생성
	apiService := api.NewService(appConfig, notificationService, buildInfo)

	// Task Service에 Notification Service 주입 (순환 참조 해결)
	taskService.SetNotificationSender(notificationService)

	// 8. 서비스 생명주기 관리 컨텍스트 설정
	// 전체 서비스의 종료 신호를 전파하는 Context(serviceStopCtx)와
	// 모든 서비스가 안전하게 종료될 때까지 대기하는 WaitGroup(serviceStopWG)을 초기화합니다.
	serviceStopCtx, serviceStopCancel := context.WithCancel(context.Background())
	serviceStopWG := &sync.WaitGroup{}

	// 9. 서비스 병렬 기동
	// 준비된 모든 서비스를 별도의 고루틴 또는 비동기 컨텍스트에서 시작합니다.
	// 하나라도 초기화에 실패하면 즉시 전체 서버 구동을 중단하고 롤백(종료) 절차를 밟습니다.
	services := []service.Service{taskService, notificationService, apiService}
	for _, s := range services {
		serviceStopWG.Add(1)
		if err := s.Start(serviceStopCtx, serviceStopWG); err != nil {
			serviceStopCancel()  // 다른 서비스들도 종료
			serviceStopWG.Wait() // 이미 시작된 서비스들의 종료를 대기
			return fmt.Errorf("핵심 서비스(%T)를 시작하는 도중 치명적인 오류가 발생했습니다: %w", s, err)
		}
	}

	// 10. OS 시그널 처리기 등록
	// 운영체제로부터의 종료 신호(SIGTERM: 정상 종료, SIGINT: Ctrl+C)를 수신할 채널을 생성합니다.
	// 이는 서버가 즉시 종료되지 않고, 진행 중인 작업을 마무리할 시간을 확보(Graceful Shutdown)하기 위함입니다.
	termC := make(chan os.Signal, 1)
	signal.Notify(termC, syscall.SIGINT, syscall.SIGTERM)

	applog.WithComponent("main").Info("Notify Server 가동이 완료되었습니다 (Ready to Serve)")

	// 11. 메인 루프 대기
	// 종료 신호가 들어올 때까지 메인 고루틴을 블로킹 상태로 유지합니다.
	sig := <-termC
	applog.WithComponentAndFields("main", applog.Fields{
		"signal": sig,
	}).Info("종료 신호(Signal)를 수신했습니다. Graceful Shutdown 프로세스를 시작합니다.")

	// 12. 서비스 종료 전파
	// 취소 함수(serviceStopCancel)를 호출하여 `serviceStopCtx`를 대기하고 있는 모든 하위 서비스에 종료를 알립니다.
	// 각 서비스는 이를 감지하고 리소스 정리, 연결 해제 등의 정리 작업을 수행해야 합니다.
	serviceStopCancel()

	// 13. 종료 타임아웃 프로세스
	// 서비스들이 무한정 종료되지 않는 상황(Deadlock 등)을 방지하기 위해 강제 종료 타임아웃(30초)을 설정합니다.
	// `serviceStopCtx`는 이미 취소되었으므로, 타임아웃 카운트는 별도의 독립적인 Context(Background)에서 시작해야 합니다.
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), shutdownTimeout)
	defer shutdownCancel()

	// 메인 고루틴이 Select 절에서 타임아웃을 감지할 수 있도록, Wait() 호출을 별도 고루틴으로 위임합니다.
	done := make(chan struct{})
	go func() {
		serviceStopWG.Wait()
		close(done)
	}()

	// 14. 종료 완료 대기 또는 강제 종료
	select {
	case <-done:
		applog.WithComponent("main").Info("모든 서비스가 리소스를 정리하고 정상적으로 종료되었습니다.")
	case <-shutdownCtx.Done():
		applog.WithComponent("main").Error("종료 타임아웃 발생: 일부 서비스가 응답하지 않아 강제 종료합니다.")
		return fmt.Errorf("종료 제한 시간(%v)을 초과하여 프로세스를 강제 종료합니다", shutdownTimeout)
	}

	return nil
}
